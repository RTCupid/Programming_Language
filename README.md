# Проект 3.3.5 Язык самурая

## Содержание
- [0. Аннотация](#аннотация)
- [1. Введение](#введение)
- [2. Методика](#методика)
- [3. Результаты и их обсуждение](#результаты-и-их-обсуждение)
- [4. Выводы](#выводы)
- [5. Приложение](#приложение)

## Аннотация

Написан frontend для моего языка программирования, который обрабатывает синтаксис функций, цикла, условного оператора, операторов ввода и вывода целых чисел, оператора присваивания и сравнения. Для первичной обработки кода из текстового файла в frontend (интерфейсной части, клиентской части) использован токенайзер (см. [Tokenizer.h](/frontend/hdr/Tokenizer.h), [Tokenizer.cpp](/frontend/src/Tokenizer.cpp)), преобразующий программу в массив токенов - структур, содержащих информацию об элементе программы: тип элемента и его значение. Для обработки массива токенов использовался алгоритм рекурсивного спуска (см. [RecursiveReader.h](/frontend/hdr/RecursiveReader.h), [RecursiveReader.cpp](/frontend/src/RecursiveReader.cpp)). По итогу рекурсивного обхода массива токенов создавалось абстрактное синтаксическое дерево, которое затем записывалось в текстовый файл в префиксном формате полной скобочной записи для дальнейшей передачи этого файла в backend (серверную часть, бэкенд). В итоге получен frontend для моего языка программирования.

Для дальнейшей обработки и компиляции написан backend (серверная часть). Он использовался для преобразования промежуточного представления (IR) в инструкции целевой архитектуры. Backend реализован для моей программы CPU процессора (см. проект [Processor](https://github.com/RTCupid/Proccessor)) и для процессора архитектуры x86-64. Реализация для моего CPU состояла из генерации кода на моём ассемблере (см. [MakeCodeAsm.h](/backend/hdr/MakeCodeAsm.h), [MakeCodeAsm.cpp](/backend/MakeCodeAsm.cpp)), для дальнейшего преобразования в выполняемый код и выполнения в моём процессоре CPU. Для второго варианта написана генерация кода на ассемблере NASM (см. [MakeCodeNasm.h](/x86_64_backend/hdr/MakeCodeNasm.h), [MakeCodeNasm.cpp](/x86_64_backend/MakeCodeNasm.cpp)). Этот код затем компилировался и выполнялся на процессоре x86-64. 

## Введение

Современные языки программирования и компиляторы часто не учитывают специфические требования узкоспециализированных задач, таких как высокоэффективные вычисления, работа с аппаратурой или предметно-ориентированные DSL (Domain-Specific Languages). Их универсальность приводит к избыточности кода и неоптимальному использованию аппаратных ресурсов, что критично для низкоуровневого программирования.

В качестве альтернативы можно использовать существующие языки (например, C или Rust) с дополнительными библиотеками или препроцессорами. Однако такой подход имеет существенные недостатки: во-первых, он не устраняет избыточность синтаксиса и семантики, во-вторых, требует значительных усилий для интеграции с аппаратурой или специализированными алгоритмами. Кроме того, подобные решения часто приводят к усложнению кодовой базы и снижению её сопровождаемости.

Разработка специализированного языка с соответствующим компилятором позволяет точно контролировать генерацию машинного кода, минимизировать накладные расходы и обеспечивать прямую работу с аппаратными возможностями. Такой подход критически важен для задач, где производительность и предсказуемость исполнения являются ключевыми требованиями.

Целью работы было изучение устройства компилятора и создание компилятора для своего языка программирования.

## Методика

Для создания своего языка программирования необходимо составить синтаксис, удобный для целевого применения, и выбрать метод для реализации фронтенда (лексического и синтаксического анализа) языка, в результате работы которого получится промежуточное представление программы. 

Для составления своего синтаксиса нужно проанализировать область применения языка. В зависимости от задачи можно использовать синтаксис, похожий на существующий язык программирования, смешать синтаксис разных языков или использовать для вдохновения эзотерические языки программирования [1]. В качестве алгоритма синтаксического анализа можно использовать рекурсивный спуск.

После работы фронтенда можно провести оптимизации с промежуточным представлением (IR). Например, можно выполнить свёртку констант и удаление нейтральных выражений (см. проект [Differentiator](https://github.com/RTCupid/Differentiator)).

Для написания бэкенда компилятора - программы, которая генерирует машинный код из промежуточного представления, необходимо определиться с архитектурой, на которой будет выполняться код.

## Результаты и их обсуждение

## Выводы

## Список литературы

1.  Примеры кода на 39 эзотерических языках программирования [Электронный ресурс]: статья. - https://habr.com/ru/companies/edison/articles/313334/ (дата обращения - 18.05.2025)
2.  Intel® Intrinsics Guide mirror [Электронный ресурс]: документация. - https://archost.xyz/immintrin/#cats=Cryptography&ig_expand=1421 (дата обращения - 09.05.2025)

## Приложение. Результаты измерений 


