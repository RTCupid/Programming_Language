# Проект 3.3.5 Язык самурая

## Содержание
- [0. Аннотация](#аннотация)
- [1. Введение](#введение)
- [2. Методика](#методика)
- [3. Результаты и их обсуждение](#результаты-и-их-обсуждение)
- [4. Выводы](#выводы)
- [5. Приложение](#приложение)

## Аннотация

Создан новый язык программирования - "Язык самурая". Он имеет С-подобный синтаксис и содержит операции, которые необходимы при написании программы для решения квадратных уравнений и программы для вычисления факториала числа. Его преимуществом перед С является возможность одновременно использовать слова по типу "add" или "multiply" и стандартные математические знаки операций, например, "+", "*", при выполнении математических преобразований. Программа представляет последовательность операторов, для разделения операторов можно использовать стандартный для синтаксиса С знак ";", либо более понятное слово "next". Также он имеет простые и понятные операторы ввода и вывода, которые идеально подходят для вычислительных программ. 

Реализован компилятор "Языка самурая" для моего эмулятора процессора и процессоров архитектуры x86-64. На стадии миддленда проведены две оптимизации: свёртка констант и удаление нейтральных выражений, эта оптимизация даёт возможность использовать выражения с константами, типа "333 * 334", не переживая за производительность. 

Проведены тесты правильности выполнения программ, а также тесты скорости выполнения кода, скомпилированного для разных процессоров. Оказалось, что скомпилированный для процессора х86-64 код выполнялся в 530 раз быстрее, чем тот, который был получен для эмулятора процессора, несмотря на то, что производились одинаковые действия, полученные из одного фронтенда. Из этого сделан вывод, что скорость выполнения программы зависит от архитектуры, для которой компилируется код, а также от того, насколько оптимальный код генерируется компилятором.

## Введение

Современные языки программирования и компиляторы могут не учитывать специфические требования узкоспециализированных задач, таких как высокоэффективные вычисления, работа с аппаратурой или предметно-ориентированные DSL (Domain-Specific Languages). Их универсальность приводит к избыточности кода и неоптимальному использованию аппаратных ресурсов, что критично для низкоуровневого программирования.

В качестве альтернативы можно использовать существующие языки (например, C или Rust) с дополнительными библиотеками или препроцессорами. Однако такой подход имеет существенные недостатки: во-первых, он не устраняет избыточность синтаксиса и семантики, во-вторых, требует значительных усилий для интеграции с аппаратурой или специализированными алгоритмами. Кроме того, подобные решения часто приводят к усложнению кодовой базы и снижению её сопровождаемости.

Разработка специализированного языка с соответствующим компилятором позволяет точно контролировать генерацию машинного кода, минимизировать накладные расходы и обеспечивать прямую работу с аппаратными возможностями. Такой подход критически важен для задач, где производительность и предсказуемость исполнения являются ключевыми требованиями.

Целью работы являлось изучение устройства компилятора, создание своего языка программирования и написание компилятора для него на эмулятор процессора и процессоры архитектуры x86-64.

## Методика

Для создания своего языка программирования необходимо составить синтаксис, удобный для целевого применения, и выбрать метод для реализации фронтенда (лексического и синтаксического анализа) языка, в результате работы которого получится промежуточное представление программы. 

Для составления своего синтаксиса нужно проанализировать область применения языка. В зависимости от задачи можно использовать синтаксис, похожий на существующий язык программирования, смешать синтаксис разных языков или использовать для вдохновения эзотерические языки программирования [[9]](https://habr.com/ru/companies/edison/articles/313334/). В качестве алгоритма синтаксического анализа можно использовать рекурсивный спуск.

После работы фронтенда можно провести оптимизации с промежуточным представлением. Например, можно выполнить свёртку констант и удаление нейтральных выражений.

Для написания бэкенда компилятора - программы, которая генерирует машинный код из промежуточного представления, необходимо определиться с архитектурой, на которой будет выполняться код.

## Результаты и их обсуждение

### Структура языка и компилятора

Выбран С-подобный синтаксис языка (см. Приложение). Набор команд составлен из тех, которые необходимы для написания программ для решения квадратных уравнений и вычисления факториала.

<div align="center"><img src="img/CPU.png"></div><br>
<div align="center"> Рис. 1. Характеристики процессора, для которого проводились измерения, полученные при помощи команды 'lscpu' в терминале Linux Mint.</div><br>

Для моего языка программирования написан фронтенд, обрабатывающий синтаксис функций, циклов, операторов условных переходов, операторов ввода и вывода целых чисел, оператора присваивания и сравнения.

Для первичной обработки кода из текстового файла во фронтенде использован лексический анализатор [[1]](/frontend/hdr/Tokenizer.h), [[2]](/frontend/src/Tokenizer.cpp), преобразующий программу в массив лексем - структур, содержащих информацию об элементе программы: тип элемента и его значение. Для обработки массива лексем использовался алгоритм рекурсивного спуска [[3]](/frontend/hdr/RecursiveReader.h), [[4]](/frontend/src/RecursiveReader.cpp). 

По итогу рекурсивного обхода массива лексем создавалось абстрактное синтаксическое дерево, которое затем представлялось в промежуточном представлении - текстовом файле в префиксном формате полной скобочной записи. Таким образом, получен готовый фронтенд для моего языка программирования.

Над промежуточным представлением проводились оптимизации: свёртка констант и удаление нейтральных выражений.

Для дальнейшей обработки и компиляции написан бэкенд. Он использовался для преобразования промежуточного представления (IR - абстрактное синтаксическое дерево) в инструкции целевой архитектуры. Бэкенд реализован для моего эмулятора CPU процессора (см. проект [Processor](https://github.com/RTCupid/Proccessor)) и для процессоров архитектуры x86-64. 

Реализация для эмулятора процессора состояла из генерации кода на моём ассемблере [[5]](/backend/hdr/MakeCodeAsm.h), [[6]](/backend/MakeCodeAsm.cpp), для дальнейшего преобразования в выполняемый код и выполнения в моём процессоре CPU. Для второго варианта написана генерация кода на ассемблере NASM [[7]](/x86_64_backend/hdr/MakeCodeNasm.h), [[8]](/x86_64_backend/MakeCodeNasm.cpp). Этот код затем компилировался при помощи NASM и выполнялся на процессоре архитектуры x86-64. 

### Результаты измерений

Для сравнения производительности кода, полученного при компиляции для эмулятора процессора, и при компиляции для процессора x86-64 (см. Рис. 1), использовался следующий код на языке Самурая:

```
a = 7;
b = 12;
c = 4;

ntimes = 10000000;

while (ntimes > 1)
{
    Discriminant = b multiply b subtract 4 multiply a multiply c;

    first_answ  = ((0 subtract 1) multiply b subtract sqrt (Discriminant)) divide (2 multiply a);
    second_answ = ((0 subtract 1) multiply b add      sqrt (Discriminant)) divide (2 multiply a);

    ntimes = ntimes - 1;
};

then_commit_seppuku
```

По результатам измерений (см. Табл. 1) видно, что код на процессоре х86-64 выполнялся в 530 раз быстрее, чем на эмуляторе процессора, несмотря на то, что производились одинаковые действия, полученные из одного фронтенда.  

| Команда                             | Всего тестов | Среднее время выполнения, с | Минимальное время выполнения, с | Максимальное время выполнения, с |
|-------------------------------------|-------------:|----------------------------:|--------------------------------:|--------------------------------:|
| `./processor/Run.exe Programm_code.txt` |            4 |              93.7 ± 0.7 |                       93.0    |                       94.6    |
| `./build/bin/nasm`                  |           20 |        (176.8 ± 3.5) ⋅ 10⁻³ |                173.2 ⋅ 10⁻³     |                184.7 ⋅ 10⁻³     |

Таблица 1. Результаты измерения времени выполнения одного кода, скомпилированного для эмулятора процессора и процессора с архитектурой x86-64. Измерение проводилось при помощи утилиты hyperfine.

Сделан вывод, что скорость выполнения программы зависит от архитектуры, для которой компилируется код. Чтобы генерировать более эффективный код, компилятор применяет оптимизации, такие как свёртка констант, удаление неиспользуемого кода и другие.

## Выводы

Использование алгоритма рекурсивного спуска для обработки массива лексем себя оправдало, так как оно позволило создать AST-дерево, достаточно точно передающее изначальный вид кода и удобное для дальнейшей обработки.

Полученный для процессора с архитектурой х86-64 код выполнялся в 530 раз быстрее, чем тот, который был получен для эмулятора процессора, хотя производились одинаковые действия, полученные из одного фронтенда. Из этого сделан вывод, что скорость выполнения программы зависит от архитектуры, для которой компилируется код, а также от того, насколько оптимальный код генерируется.

## Список литературы

1-2. Лексический анализатор [Файл]: ссылки на файлы из репозитория. - [Tokenizer.h](/frontend/hdr/Tokenizer.h)[Tokenizer.cpp](/frontend/src/Tokenizer.cpp)

3-4. Синтаксический анализатор, реализованный с использованием алгоритма рекурсивного спуска [Файл]: ссылки на файлы из репозитория. - [RecursiveReader.h](/frontend/hdr/RecursiveReader.h), [RecursiveReader.cpp](/frontend/src/RecursiveReader.cpp) 

5-6. Бэкенд для генерации кода, выполняемого на эмуляторе процессора [Файл]: ссылки на файлы из репозитория. -  [MakeCodeAsm.h](/backend/hdr/MakeCodeAsm.h), [MakeCodeAsm.cpp](/backend/MakeCodeAsm.cpp)

7-8. Бэкенд для генерации кода, выполняемого на процессорах архитектуры x86-64 [Файл]: ссылки на файлы из репозитория. -  [MakeCodeNasm.h](/x86_64_backend/hdr/MakeCodeNasm.h), [MakeCodeNasm.cpp](/x86_64_backend/MakeCodeNasm.cpp))

9.  Примеры кода на 39 эзотерических языках программирования [Электронный ресурс]: статья. - https://habr.com/ru/companies/edison/articles/313334/ (дата обращения - 18.05.2025)

# Приложение 
## Синтаксис реализованного языка программирования

Тесты, используемые для отладки приведены в папке `./tests`[1] репозитория. На этих примерах можно изучить синтаксис языка. 

1. Тестовые программы [Файл]: ссылка на папку из репозитория. - [tests](/tests/).
