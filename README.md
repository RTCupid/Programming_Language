# Проект 3.3.5 Язык самурая

## Содержание
- [0. Аннотация](#аннотация)
- [1. Введение](#введение)
- [2. Методика](#методика)
- [3. Результаты и их обсуждение](#результаты-и-их-обсуждение)
- [4. Выводы](#выводы)
- [5. Приложение](#приложение)

## Аннотация
Написан frontend для моего языка программирования, который обрабатывает синтаксис функций, цикла, условного оператора, операторов ввода и вывода целых чисел, оператора присваивания и сравнения. Для первичной обработки кода из текстового файла в frontend (интерфейсной части, клиентской части) использован токенайзер (см. [Tokenizer.h](/frontend/hdr/Tokenizer.h), [Tokenizer.cpp](/frontend/src/Tokenizer.cpp)), преобразующий программу в массив токенов - структур, содержащих информацию об элементе программы: тип элемента и его значение. Для обработки массива токенов использовался алгоритм рекурсивного спуска (см. [RecursiveReader.h](/frontend/hdr/RecursiveReader.h), [RecursiveReader.cpp](/frontend/src/RecursiveReader.cpp)). По итогу рекурсивного обхода массива токенов создавалось абстрактное синтаксическое дерево, которое затем записывалось в текстовый файл в префиксном формате полной скобочной записи для дальнейшей передачи этого файла в backend (серверную часть, бэкенд). В итоге получен frontend для моего языка программирования.

Для дальнейшей обработки и компиляции написан backend (серверная часть). Он использовался для преобразования промежуточного представления (IR) в инструкции целевой архитектуры. Backend реализован для моей программы CPU процессора (см. [Processor](https://github.com/RTCupid/Proccessor)) и для процессора архитектуры x86-64. Реализация для моего CPU состояла из генерации кода на моём ассемблере (см. [MakeCodeAsm.h](/backend/hdr/MakeCodeAsm.h), [MakeCodeAsm.cpp](/backend/MakeCodeAsm.cpp)), для дальнейшего преобразования в выполняемый код и выполнения в моём процессоре CPU. Для второго варианта написана генерация кода на ассемблере NASM (см. [MakeCodeNasm.h](/x86_64_backend/hdr/MakeCodeNasm.h), [MakeCodeNasm.cpp](/x86_64_backend/MakeCodeNasm.cpp)). Этот код затем компилировался и выполнялся на процессоре x86-64. 

## Введение

Современные языки программирования и компиляторы часто не учитывают специфические требования узкоспециализированных задач, таких как высокоэффективные вычисления, работа с аппаратурой или предметно-ориентированные DSL (Domain-Specific Languages). Их универсальность приводит к избыточности кода и неоптимальному использованию аппаратных ресурсов, что критично для низкоуровневого программирования.

В качестве альтернативы можно использовать существующие языки (например, C или Rust) с дополнительными библиотеками или препроцессорами. Однако такой подход имеет существенные недостатки: во-первых, он не устраняет избыточность синтаксиса и семантики, во-вторых, требует значительных усилий для интеграции с аппаратурой или специализированными алгоритмами. Кроме того, подобные решения часто приводят к усложнению кодовой базы и снижению её сопровождаемости.

Разработка специализированного языка с соответствующим компилятором позволяет точно контролировать генерацию машинного кода, минимизировать накладные расходы и обеспечивать прямую работу с аппаратными возможностями. Такой подход критически важен для задач, где производительность и предсказуемость исполнения являются ключевыми требованиями.

Целью работы было изучение устройства компилятора и создание компилятора для своего языка программирования.

## Методика


## Результаты и их обсуждение

## Выводы

## Список литературы

1.
2.  Intel® Intrinsics Guide mirror [Электронный ресурс]: документация. - https://archost.xyz/immintrin/#cats=Cryptography&ig_expand=1421 (дата обращения - 09.05.2025)

## Приложение. Результаты измерений 


