# Проект 3.3.5 Язык самурая

## Содержание
- [0. Аннотация](#аннотация)
- [1. Введение](#введение)
- [2. Методика](#методика)
- [3. Результаты и их обсуждение](#результаты-и-их-обсуждение)
- [4. Выводы](#выводы)
- [5. Приложение](#приложение)

## Аннотация

Написан фронтенд - часть компилятора, принимающая на вход пользовательскую программу на языке высокого уровня и переводящая её в промежуточное представление, для моего языка программирования, который обрабатывает синтаксис функций, цикла, условного оператора, операторов ввода и вывода целых чисел, оператора присваивания и сравнения.

Для первичной обработки кода из текстового файла во фронтенде использован лексический анализатор [[1]](/frontend/hdr/Tokenizer.h), [[2]](/frontend/src/Tokenizer.cpp), преобразующий программу в массив лексем - структур, содержащих информацию об элементе программы: тип элемента и его значение. Для обработки массива лексем использовался алгоритм рекурсивного спуска [[3]](/frontend/hdr/RecursiveReader.h), [[4]](/frontend/src/RecursiveReader.cpp). 

По итогу рекурсивного обхода массива лексем создавалось абстрактное синтаксическое дерево, которое затем записывалось в текстовый файл в префиксном формате полной скобочной записи для дальнейшей передачи этого файла в бэкенд - часть компилятора, которая выполняет оптимизации и генерирует машинный код. Таким образом, получен готовый фронтенд для моего языка программирования.

Для дальнейшей обработки и компиляции написан бэкенд. Он использовался для преобразования промежуточного представления (IR - абстрактное синтаксическое дерево) в инструкции целевой архитектуры. Бэкенд реализован для моего эмулятора CPU процессора (см. проект [Processor](https://github.com/RTCupid/Proccessor)) и для процессоров архитектуры x86-64. 

Реализация для эмулятора процессора состояла из генерации кода на моём ассемблере [[5]](/backend/hdr/MakeCodeAsm.h), [[6]](/backend/MakeCodeAsm.cpp), для дальнейшего преобразования в выполняемый код и выполнения в моём процессоре CPU. Для второго варианта написана генерация кода на ассемблере NASM [[7]](/x86_64_backend/hdr/MakeCodeNasm.h), [[8]](/x86_64_backend/MakeCodeNasm.cpp). Этот код затем компилировался и выполнялся на процессоре архитектуры x86-64. 

Сравнили скорость выполнения кода, скомпилированного для разных процессоров. Для этого измерили время выполнения кода на процессоре архитектуры x86-64 и на эмуляторе процессора. Получили, что скомпилированный для процессора х86-64 код выполнялся в 530 раз быстрее, чем тот, который был получен для эмулятора процессора, несмотря на то, что производились одинаковые действия, полученные из одного фронтенда. Из этого сделан вывод, что скорость выполнения программы зависит от архитектуры, для которой компилируется код, а также от того, насколько оптимальный код генерируется.

## Введение

Современные языки программирования и компиляторы могут не учитывать специфические требования узкоспециализированных задач, таких как высокоэффективные вычисления, работа с аппаратурой или предметно-ориентированные DSL (Domain-Specific Languages). Их универсальность приводит к избыточности кода и неоптимальному использованию аппаратных ресурсов, что критично для низкоуровневого программирования.

В качестве альтернативы можно использовать существующие языки (например, C или Rust) с дополнительными библиотеками или препроцессорами. Однако такой подход имеет существенные недостатки: во-первых, он не устраняет избыточность синтаксиса и семантики, во-вторых, требует значительных усилий для интеграции с аппаратурой или специализированными алгоритмами. Кроме того, подобные решения часто приводят к усложнению кодовой базы и снижению её сопровождаемости.

Разработка специализированного языка с соответствующим компилятором позволяет точно контролировать генерацию машинного кода, минимизировать накладные расходы и обеспечивать прямую работу с аппаратными возможностями. Такой подход критически важен для задач, где производительность и предсказуемость исполнения являются ключевыми требованиями.

Целью работы было изучение устройства компилятора, создание своего языка программирования и компилятора для него.

## Методика

Для создания своего языка программирования необходимо составить синтаксис, удобный для целевого применения, и выбрать метод для реализации фронтенда (лексического и синтаксического анализа) языка, в результате работы которого получится промежуточное представление программы. 

Для составления своего синтаксиса нужно проанализировать область применения языка. В зависимости от задачи можно использовать синтаксис, похожий на существующий язык программирования, смешать синтаксис разных языков или использовать для вдохновения эзотерические языки программирования [[9]](https://habr.com/ru/companies/edison/articles/313334/). В качестве алгоритма синтаксического анализа можно использовать рекурсивный спуск.

После работы фронтенда можно провести оптимизации с промежуточным представлением. Например, можно выполнить свёртку констант и удаление нейтральных выражений.

Для написания бэкенда компилятора - программы, которая генерирует машинный код из промежуточного представления, необходимо определиться с архитектурой, на которой будет выполняться код.

## Результаты и их обсуждение

### Структура языка и компилятора

Выбран С-подобный синтаксис языка (см. Приложение). Набор команд составлен из тех, которые необходимы для написания программ для решения квадратных уравнений и вычисления факториала.

Для выполнения программ на "языке Самурая" - созданном языке программирования, выбраны процессоры архитектуры x86-64 и мой эмулятор процессора CPU (см. проект [Processor](https://github.com/RTCupid/Proccessor)).

Фронтенд реализован в виде лексического анализа - разделения на лексемы, и синтаксического анализа. Для лексического анализа принято решение использовать токенайзер, преобразующий программу из текстового файла в массив лексем - структур, содержащих информацию о типе элемента и его значении. Для проведения синтаксического анализа использовался алгоритм рекурсивного спуска.

В промежуточном представлении код представлялся полной скобочной записью в префиксном формате. По такому представлению можно без проблем восстановить AST-дерево, для которого можно провести такие оптимизации, как свёртка констант и удаление неиспользуемого кода (нейтральных выражений) (см. проект [Differentiator](https://github.com/RTCupid/Differentiator)). 

В бэкенде из промежуточного представления строилось AST-дерево. Затем производился обход дерева. В процессе обхода генерировался код на ассемблере, который компилировался при помощи nasm.

### Результаты измерений

Для сравнения производительности кода, полученного при компиляции для эмулятора процессора, и при компиляции для процессора x86-64 (см. Рис. 1), использовался следующий код на языке Самурая:

```
a = 7;
b = 12;
c = 4;

ntimes = 10000000;

while (ntimes > 1)
{
    Diskriminant = b multiply b subtract 4 multiply a multiply c;

    first_answ  = ((0 subtract 1) multiply b subtract sqrt (Diskriminant)) divide (2 multiply a);
    second_answ = ((0 subtract 1) multiply b add      sqrt (Diskriminant)) divide (2 multiply a);

    ntimes = ntimes - 1;
};

then_commit_seppuku
```

<div align="center"><img src="img/CPU.png"></div><br>
<div align="center"> Рис. 1. Характеристики процессора, для которого проводились измерения, полученные при помощи команды 'lscpu' в терминале Linux Mint.</div><br>

По результатам измерений (см. Табл. 1) видно, что код на процессоре х86-64 выполнялся в 530 раз быстрее, чем на эмуляторе процессора, несмотря на то, что производились одинаковые действия, полученные из одного фронтенда.  

| Команда                             | Всего тестов | Среднее время выполнения, с | Минимальное время выполнения, с | Максимальное время выполнения, с |
|-------------------------------------|-------------:|----------------------------:|--------------------------------:|--------------------------------:|
| `./processor/Run.exe Programm_code.txt` |            4 |              93.7 ± 0.7 |                       93.0    |                       94.6    |
| `./build/bin/nasm`                  |           20 |        (176.8 ± 3.5) ⋅ 10⁻³ |                173.2 ⋅ 10⁻³     |                184.7 ⋅ 10⁻³     |
Таблица 1. Результаты измерения времени выполнения одного кода, скомпилированного для эмулятора процессора и процессора с архитектурой x86-64. Измерение проводилось при помощи утилиты hyperfine.

Сделан вывод, что скорость выполнения программы зависит от архитектуры, для которой компилируется код. Чтобы генерировать более эффективный код, компилятор применяет оптимизации, такие как свёртка констант, удаление неиспользуемого кода и другие.

## Выводы

Использование алгоритма рекурсивного спуска для обработки массива лексем себя оправдало, так как оно позволило создать AST-дерево, достаточно точно передающее изначальный вид кода и удобное для дальнейшей обработки.

Полученный для процессора с архитектурой х86-64 код выполнялся в 530 раз быстрее, чем тот, который был получен для эмулятора процессора, хотя производились одинаковые действия, полученные из одного фронтенда. Из этого сделан вывод, что скорость выполнения программы зависит от архитектуры, для которой компилируется код, а также от того, насколько оптимальный код генерируется.

## Список литературы

1-2. Лексический анализатор [Файл]: ссылки на файлы из репозитория. - [Tokenizer.h](/frontend/hdr/Tokenizer.h)[Tokenizer.cpp](/frontend/src/Tokenizer.cpp)

3-4. Синтаксический анализатор, реализованный с использованием алгоритма рекурсивного спуска [Файл]: ссылки на файлы из репозитория. - [RecursiveReader.h](/frontend/hdr/RecursiveReader.h), [RecursiveReader.cpp](/frontend/src/RecursiveReader.cpp) 

5-6. Бэкенд для генерации кода, выполняемого на эмуляторе процессора [Файл]: ссылки на файлы из репозитория. -  [MakeCodeAsm.h](/backend/hdr/MakeCodeAsm.h), [MakeCodeAsm.cpp](/backend/MakeCodeAsm.cpp)

7-8. Бэкенд для генерации кода, выполняемого на процессорах архитектуры x86-64 [Файл]: ссылки на файлы из репозитория. -  [MakeCodeNasm.h](/x86_64_backend/hdr/MakeCodeNasm.h), [MakeCodeNasm.cpp](/x86_64_backend/MakeCodeNasm.cpp))

9.  Примеры кода на 39 эзотерических языках программирования [Электронный ресурс]: статья. - https://habr.com/ru/companies/edison/articles/313334/ (дата обращения - 18.05.2025)

# Приложение 
## Синтаксис реализованного языка программирования

Тесты, используемые для отладки приведены в папке `./tests`[1] репозитория. На этих примерах можно изучить синтаксис языка. 

1. Тестовые программы [Файл]: ссылка на папку из репозитория. - [tests](/tests/).
